// Author: Matteo Daniele <matteo.daniele@polimi.it>
// disc rotor module for mbdyn
#ifndef MODULE_ROTOR_DISC_H
#define MODULE_ROTOR_DISC_H

extern bool RotorDiscSet();

#include "elem.h"
#include "indvel.h"
#include "dataman.h"
#include "userelem.h"
//#include "strforce.h"
//#include "tpldrive_impl.h"
//#include "strforce_impl.h"

/*
FROM PROUTY "HELICOPTER PERFORMANCE, STABILITY AND OCONTROL, CHAPTER 3"
V1 IS CALLED CONSTANT MOMENTUM INDUCED VELOCITY:
GOOD APPROXIMATION OF INDUCED VELOCITY AT SPEED > 30KT
*/

//class RotorDisc : AerodynamicElem, public UserDefinedElem
class RotorDisc : public UserDefinedElem
{
private:

    const StructNode* pHubNode;
    // position of the force wrt hub reference node
    Vec3 HubNodeArm;
    // the disc rotor force vector (Thrust oriented along the z of the local rf)
    Vec3 OutputThrust;
    // moment vector (for couple generated by induced+profile)
    Vec3 OutputCouple;

    // orientation matrix of thrust vector
    Mat3x3 RThrustOrientation;

    // control input (rad)
    const DriveCaller* pXColl;

    //rotor angular speed driver (rad/s)
    const DriveCaller* pOmega;

    // partial derivatives initialization
    doublereal dMu[5];
    doublereal dLambda[5];

    // partial derivatives of thrust components for Jacobian assembly
    doublereal dT0[5];
    doublereal dTTheta[5];
    doublereal dTLambda[5];

    // elements of thrust that will be updated at each time step
    doublereal T0;
    doublereal TTheta;
    doublereal TLambda;

    // thrust value at each time step
    doublereal Thrust;
    // induced drag value at each time step
    doublereal DragInduced, DragProfile;
    // couple value at each time step
    doublereal CoupleInduced, CoupleProfile, Couple;
    // power at each time step
    doublereal PowerInduced, PowerProfile, Power;
    doublereal PowerInducedHover, 
    PowerProfileHover, PowerHover;
    doublereal CpInduced, CpProfile;
    bool bWithDrag;
    // elements of thrust for jacobian assembly
    doublereal dThrust[5];
    // alpha tippatplane
    doublereal alphaTPP;
    // ct, cp, fom
    doublereal Ct, Cp, FOM;
    doublereal CtSigma, CpSigma;

    // air properties from the properties of the aerodynamic element (inherited)
    doublereal rho; // density
    // partial derivatives of advance ratio
    void dMuCalc();
    // partial derivatives of inflow ratio
    void dLambdaCalc();

    // partial derivatives of thrust components for jacobian assembly
    void dT0Calc();
    void dTThetaCalc();
    void dTLambdaCalc();

    // thrust components
    void T0Calc();
    void TThetaCalc();
    void TLambdaCalc();
    // thrust and induced power (output as private data?)
    void ThrustCalc();
    void PowerCalc();


    // jacobians of thrust
    void dTCalc();

    // state-dependent variable calculation
    void updateStatesDeps();

    // update inputs - check saturation limits
    void inputSaturation();
    // calculate cl (with stall effects)
    void computeCLInit(doublereal RDecayDeg=1.0);
    void computeCL();
    // compute thrust
    void computeRotorThrust();
    // method to build partial derivatives and jacobians
    void assemblyJacobian();

    void computeLambdaNewman(int itMax=100, doublereal tollMax=1.e-6);

    ////////////////////////////////////////////////////////////////////////


    // dimensional data of the  rotor
    doublereal RotorRadius;     //  rotor radius [m]
    doublereal Chord;           // blade chord [m]
    int NBlades;                // blade number
    doublereal DiscArea;        //  rotor disc area [m^2]
    doublereal RotorSolidity;   //  rotor solidity [-]
    doublereal Cl0;             // lift slope at alpha=0 [-]
    doublereal ClAlpha;         // lift slope curve [1/rad]
    doublereal Cl;              // lift coefficient
    doublereal Cd;              // drag coefficient
    doublereal Cd0,Cd1,Cd2;
    doublereal BladeTwist;      // twist angle at tip [rad]

    // Cl stall angle [rad]
    doublereal AOAStallMin = std::numeric_limits<doublereal>::min();
    doublereal AOAStallMax = std::numeric_limits<doublereal>::max();
    doublereal clMin;
    doublereal clMax;
    bool bWithStallLimits;

    // main rotor data for v1hover
    doublereal hubs_distance;           // distance between mr and tr hub [m]
    doublereal mr_nominal_power_shp;    // main rotor nominal power, OGE [hp]
    doublereal mr_nominal_omega;        // main rotor nominal angular speed [rad/s]

    // if we consider a rotor disc model
    doublereal MTOW; // helicopter max takeoff weight [kg]
    const doublereal g = 9.81;

    // shp2W
    const doublereal hp2W = 745.7; // conversion factor, horsepower to watt
    const doublereal W2hp = 1.0/hp2W; // conversion factor, horsepower to watt
    const doublereal deg2rad = M_PI/180.0;
    const doublereal rad2deg = 1.0/deg2rad;
    // part of v1h depending only on the constant factors:
    // v1hPart = sqrt(Th/2A), where Th is the required rotor
    // thrust in hover to compensate for nominal rotor torque
    // induced power in hover
    doublereal ThrustHover;
    doublereal v1hPart;

    // airspeed in body frame acting on  rotor center node (x pointing towards nose, z pointing outwards)
    Vec3 VTrHub;
    // rotor angular speed
    doublereal RotorOmega;
    // air density defined above
    // doublereal rho;
    // STATE DEPENDENT VARIABLES
    doublereal u, v, w;
    doublereal Vtot, Vtot2;
    // tip speed
    doublereal Vtip;
    doublereal Vtip2;
    // advance ratio
    doublereal mu, mu2, mu4;
    // v1h: induced velocity in hover
    doublereal v1h;
    // CONSTANT MOMENTUM INDUCED VELOCITY
    doublereal a_v1; // sqrt((vtot/2)^2+v1h^4)
    doublereal V1;
    // inflow ratio - basic case
    doublereal lambda;
    // inflow ratio - newman
    doublereal lambdaNewman;

    // pedal input [rad]
    doublereal thetaColl;
    // pedal angle limits [rad]
    doublereal thetaCollMin = std::numeric_limits<doublereal>::min();
    doublereal thetaCollMax = std::numeric_limits<doublereal>::max();
    bool bWithCollSaturation;

    Vec3 F;
    Vec3 M;

    // for stall effect
    doublereal  xpMin,ypMin,xpMax,ypMax,
                x0Min,y0Min,x0Max,y0Max,
                xbMin,ybMin,xbMax,ybMax,
                RDecay, a1,
                mb, qbMin, qbMax,
                AOAAfterDecayMin, AOAAfterDecayMax;

public:

    // constructor inherits FollowerForceClass constructor
    RotorDisc( unsigned int uL, const DofOwner *pDO,
                    DataManager* pDM, MBDynParser& HP);
    virtual ~RotorDisc();

    enum PrivData {

        PRIV_THETACOLL = 1,
        PRIV_OMEGA,
        PRIV_THRUST,
        PRIV_COUPLEINDUCED,
        PRIV_COUPLEPROFILE,
        PRIV_COUPLE,
        PRIV_POWERINDUCED,
        PRIV_POWERPROFILE,
        PRIV_POWER,
        PRIV_POWERINDUCEDHOVER,
        PRIV_POWERPROFILEHOVER,
        PRIV_POWERHOVER,
        PRIV_ALPHATPP,
        PRIV_RHO,
        PRIV_LAMBDA,
        PRIV_V1,
        PRIV_V1H,
        PRIV_VHUBX,
        PRIV_VHUBY,
        PRIV_VHUBZ,
        PRIV_CPINDUCED,
        PRIV_CPPROFILE,
        PRIV_CP,
        PRIV_CPSIGMA,
        PRIV_CT,
        PRIV_CTSIGMA,
        PRIV_FOM,
        LASTPRIVDATA
    };


    ////////////////////////////////////////////////////////////////////////
	virtual void WorkSpaceDim(integer* piNumRows, integer* piNumCols) const;
    virtual void InitialWorkSpaceDim(integer* piNumRows, integer* piNumCols) const;
    //contributo al file di restart
    std::ostream& Restart(std::ostream& out) const;
    // assemblaggio yacobiano
    VariableSubMatrixHandler& AssJac(   VariableSubMatrixHandler& WorkMat,
                                        doublereal dCoef,
	                                    const VectorHandler& /* XCurr */ ,
	                                    const VectorHandler& /* XPrimeCurr */ );
    // assemblaggio residuo
    SubVectorHandler& AssRes(   SubVectorHandler& WorkVec,
	                            doublereal /* dCoef */ ,
	                            const VectorHandler& /* XCurr */ ,
	                            const VectorHandler& /* XPrimeCurr */ );
    unsigned int iGetNumPrivData() const;
    unsigned int iGetPrivDataIdx(const char* s) const;
    doublereal dGetPrivData(unsigned int i) const;
    int iGetNumConnectedNodes() const;
	void GetConnectedNodes(std::vector<const Node *>& connectedNodes) const;
	void SetValue(DataManager *pDM, VectorHandler& X, VectorHandler& XP,
		SimulationEntity::Hints *ph);
	virtual unsigned int iGetInitialNumDof() const;
    // output
    virtual void Output(OutputHandler& OH) const;
    /* Contributo allo jacobiano durante l'assemblaggio iniziale */
    VariableSubMatrixHandler& InitialAssJac(VariableSubMatrixHandler& WorkMat,
                                            const VectorHandler& /* XCurr */ );
    /* Contributo al residuo durante l'assemblaggio iniziale */
    SubVectorHandler& InitialAssRes(SubVectorHandler& WorkVec,
                                    const VectorHandler& /* XCurr */ );

    //#########################################################################

};

#endif // ! MODULE_ROTOR_DISC_H

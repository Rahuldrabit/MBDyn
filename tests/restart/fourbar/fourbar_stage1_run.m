% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2021
%
% Pierangelo Masarati	<masarati@aero.polimi.it>
% Paolo Mantegazza	<mantegazza@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
%
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%

try
  clear all;
  close all;

  pkg_prefix = getenv("OCT_PKG_INSTALL_PREFIX");

  if (~isempty(pkg_prefix))
    pkg("local_list", fullfile(pkg_prefix, "octave_packages"));
  endif

  NBEAMS = 5;

  L_1 = 0.12;
  L_2 = 0.24;
  L_3 = 0.12;

  EA_1 = 5.29920e+007;
  GAY_1 = 1.68803e+007;
  GAZ_1 = 1.68803e+007;
  GJ_1 = 7.33488e+002;
  EJY_1 = 1.13050e+003;
  EJZ_1 = 1.13050e+003;

  m_1 = 1.99680e+000;
  J1_1 = 8.51968e-005;
  J2_1 = 4.25984e-005;
  J3_1 = 4.25984e-005;

  EA_2 = 5.29920e+007;
  GAY_2 = 1.68803e+007;
  GAZ_2 = 1.68803e+007;
  GJ_2 = 7.33488e+002;
  EJY_2 = 1.13050e+003;
  EJZ_2 = 1.13050e+003;

  m_2 = 1.99680e+000;
  J1_2 = 8.51968e-005;
  J2_2 = 4.25984e-005;
  J3_2 = 4.25984e-005;

  EA_3 = 1.32480e+007;
  GAY_3 = 4.22008e+006;
  GAZ_3 = 4.22008e+006;
  GJ_3 = 4.58430e+001;
  EJY_3 = 7.06560e+001;
  EJZ_3 = 7.06560e+001;

  m_3 = 4.99200e-001;
  J1_3 = 5.32480e-006;
  J2_3 = 2.66240e-006;
  J3_3 = 2.66240e-006;

  OMEGA = 0.6;

  fd = fopen('fourbar.set', 'w');
  fprintf(fd, '# generated by fourbar_gen.m; do not edit\n');
  fprintf(fd, '\n');

  fprintf(fd, 'set: const integer N_BEAM_NODES = %d;\n', 3*(2*NBEAMS + 1));
  fprintf(fd, 'set: const integer N_BEAMS = %d;\n', 3*NBEAMS);

  fprintf(fd, '\n');

  fprintf(fd, 'set: const integer BAR_1 = %d;\n', 1000);
  fprintf(fd, 'set: const integer BAR_2 = %d;\n', 2000);
  fprintf(fd, 'set: const integer BAR_3 = %d;\n', 3000);

  fprintf(fd, '\n');

  fprintf(fd, 'set: const integer POINT_A_BAR_1 = %d;\n', 1000);
  fprintf(fd, 'set: const integer POINT_B_BAR_1 = %d;\n', 1000 + 2*NBEAMS);
  fprintf(fd, 'set: const integer POINT_B_BAR_2 = %d;\n', 2000);
  fprintf(fd, 'set: const integer POINT_C_BAR_2 = %d;\n', 2000 + 2*NBEAMS);
  fprintf(fd, 'set: const integer POINT_C_BAR_3 = %d;\n', 3000);
  fprintf(fd, 'set: const integer POINT_D_BAR_3 = %d;\n', 3000 + 2*NBEAMS);

  fprintf(fd, '\n');

  fprintf(fd, 'set: const real L_1 = %+16.8e;\n', L_1);
  fprintf(fd, 'set: const real EA_1 = %+16.8e;\n', EA_1);
  fprintf(fd, 'set: const real GAY_1 = %+16.8e;\n', GAY_1);
  fprintf(fd, 'set: const real GAZ_1 = %+16.8e;\n', GAZ_1);
  fprintf(fd, 'set: const real GJ_1 = %+16.8e;\n', GJ_1);
  fprintf(fd, 'set: const real EJY_1 = %+16.8e;\n', EJY_1);
  fprintf(fd, 'set: const real EJZ_1 = %+16.8e;\n', EJZ_1);

  fprintf(fd, 'set: const real m_1 = %+16.8e;\n', m_1);
  fprintf(fd, 'set: const real J1_1 = %+16.8e;\n', J1_1);
  fprintf(fd, 'set: const real J2_1 = %+16.8e;\n', J2_1);
  fprintf(fd, 'set: const real J3_1 = %+16.8e;\n', J3_1);

  fprintf(fd, '\n');

  fprintf(fd, 'set: const real L_2 = %+16.8e;\n', L_2);
  fprintf(fd, 'set: const real EA_2 = %+16.8e;\n', EA_2);
  fprintf(fd, 'set: const real GAY_2 = %+16.8e;\n', GAY_2);
  fprintf(fd, 'set: const real GAZ_2 = %+16.8e;\n', GAZ_2);
  fprintf(fd, 'set: const real GJ_2 = %+16.8e;\n', GJ_2);
  fprintf(fd, 'set: const real EJY_2 = %+16.8e;\n', EJY_2);
  fprintf(fd, 'set: const real EJZ_2 = %+16.8e;\n', EJZ_2);

  fprintf(fd, 'set: const real m_2 = %+16.8e;\n', m_2);
  fprintf(fd, 'set: const real J1_2 = %+16.8e;\n', J1_2);
  fprintf(fd, 'set: const real J2_2 = %+16.8e;\n', J2_2);
  fprintf(fd, 'set: const real J3_2 = %+16.8e;\n', J3_2);

  fprintf(fd, '\n');

  fprintf(fd, 'set: const real L_3 = %+16.8e;\n', L_3);
  fprintf(fd, 'set: const real EA_3 = %+16.8e;\n', EA_3);
  fprintf(fd, 'set: const real GAY_3 = %+16.8e;\n', GAY_3);
  fprintf(fd, 'set: const real GAZ_3 = %+16.8e;\n', GAZ_3);
  fprintf(fd, 'set: const real GJ_3 = %+16.8e;\n', GJ_3);
  fprintf(fd, 'set: const real EJY_3 = %+16.8e;\n', EJY_3);
  fprintf(fd, 'set: const real EJZ_3 = %+16.8e;\n', EJZ_3);

  fprintf(fd, 'set: const real m_3 = %+16.8e;\n', m_3);
  fprintf(fd, 'set: const real J1_3 = %+16.8e;\n', J1_3);
  fprintf(fd, 'set: const real J2_3 = %+16.8e;\n', J2_3);
  fprintf(fd, 'set: const real J3_3 = %+16.8e;\n', J3_3);

  fprintf(fd, '\n');

  fprintf(fd, 'set: real DAMPING_FACTOR = 0;\n');

  fprintf(fd, '\n');

  fprintf(fd, 'set: real OMEGA = %+16.8e;\n', OMEGA);

  fprintf(fd, '\n');
  fprintf(fd, '# vim:ft=mbd\n');

  fclose(fd);


  fd = fopen('fourbar.ref', 'w');
  fprintf(fd, '# generated by fourbar_gen.m; do not edit\n');

  fprintf(fd, '\n');
  fprintf(fd, 'reference: 0,\n');
  fprintf(fd, '\treference, global, null,\n');
  fprintf(fd, '\treference, global, eye,\n');
  fprintf(fd, '\treference, global, null,\n');
  fprintf(fd, '\treference, global, null;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# point A, ground hinge of bar 1\n');
  fprintf(fd, 'reference: 11,\n');
  fprintf(fd, '\treference, 0, null,\n');
  fprintf(fd, '\treference, 0, eye,\n');
  fprintf(fd, '\treference, 0, null,\n');
  fprintf(fd, '\treference, 0, 0., OMEGA, 0.;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# at mid point of bar 1, axis 1 along bar 1 (global axis 3)\n');
  fprintf(fd, 'reference: 1,\n');
  fprintf(fd, '\treference, 11, 0., 0., L_1/2,\n');
  fprintf(fd, '\treference, 11, 1, 0., 0., 1., 2, -1., 0., 0.,\n');
  fprintf(fd, '\treference, 11, null,\n');
  fprintf(fd, '\treference, 11, null;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# top end of bar 1, hinge between bars 1 & 2\n');
  fprintf(fd, 'reference: 12,\n');
  fprintf(fd, '\treference, 0, 0., 0., L_1,\n');
  fprintf(fd, '\treference, 0, eye,\n');
  fprintf(fd, '\treference, 11, null,\n');
  fprintf(fd, '\treference, 0, null;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# at mid point of bar 2, axis 1 along bar axis, axis 2 along global axis 3\n');
  fprintf(fd, 'reference: 2,\n');
  fprintf(fd, '\treference, 12, L_2/2, 0., 0.,\n');
  fprintf(fd, '\treference, 12, 1, 1., 0., 0., 2, 0., 0., 1.,\n');
  fprintf(fd, '\treference, 12, null,\n');
  fprintf(fd, '\treference, 12, null;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# ground hinge of bar 3\n');
  fprintf(fd, 'reference: 13,\n');
  fprintf(fd, '\treference, 0, L_2, 0., 0.,\n');
  fprintf(fd, '\treference, 0, eye,\n');
  fprintf(fd, '\treference, 0, null,\n');
  fprintf(fd, '\treference, 0, 0., OMEGA, 0.;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# at mid point of bar 3, axis 1 along bar axis (negative global axis 3), axis 2 along global axis 1\n');
  fprintf(fd, 'reference: 3,\n');
  fprintf(fd, '\treference, 13, 0., 0., L_3/2,\n');
  fprintf(fd, '\treference, 13, 1, 0., 0., -1., 2, 1., 0., 0.,\n');
  fprintf(fd, '\treference, 13, null,\n');
  fprintf(fd, '\treference, 13, null;\n');

  fprintf(fd, '\n');
  fprintf(fd, '# vim:ft=mbd\n');

  fclose(fd);


  fd = fopen('fourbar.nod', 'w');
  fprintf(fd, '# generated by fourbar_gen.m; do not edit\n');
  fprintf(fd, '\n');

  DL = L_1/(2*NBEAMS);
  for i = 0:2*NBEAMS,
    fprintf(fd, 'structural: BAR_1 + %d, dynamic,\n', i);
    fprintf(fd, '\treference, 1, %+16.8e,%+16.8e,%+16.8e,\n', (i - NBEAMS)*DL, 0., 0.);
    fprintf(fd, '\treference, 1, eye,\n');
    fprintf(fd, '\treference, 1, null,\n');
    fprintf(fd, '\treference, 1, null;\n');
  end

  DL = L_2/(2*NBEAMS);
  for i = 0:2*NBEAMS,
    fprintf(fd, 'structural: BAR_2 + %d, dynamic,\n', i);
    fprintf(fd, '\treference, 2, %+16.8e,%+16.8e,%+16.8e,\n', (i - NBEAMS)*DL, 0., 0.);
    fprintf(fd, '\treference, 2, eye,\n');
    if (i == 2*NBEAMS),
      fprintf(fd, '\t\torientation description, orientation matrix,\n');
    end
    fprintf(fd, '\treference, 2, null,\n');
    fprintf(fd, '\treference, 2, null;\n');
  end

  DL = L_3/(2*NBEAMS);
  for i = 0:2*NBEAMS,
    fprintf(fd, 'structural: BAR_3 + %d, dynamic,\n', i);
    fprintf(fd, '\treference, 3, %+16.8e,%+16.8e,%+16.8e,\n', (i - NBEAMS)*DL, 0., 0.);
    fprintf(fd, '\treference, 3, eye,\n');
    fprintf(fd, '\treference, 3, null,\n');
    fprintf(fd, '\treference, 3, null;\n');
  end

  fprintf(fd, '\n');
  fprintf(fd, '# vim:ft=mbd\n');

  fclose(fd);


  fd = fopen('fourbar.elm', 'w');
  fprintf(fd, '# generated by fourbar_gen.m; do not edit\n');
  fprintf(fd, '\n');

  for j = 1:3,
    for i = 0:2*NBEAMS,
      if (i == 0),
        DMF = 1/2;
        CMF = 1/4;
        J1F = 1/2;
        J2F = 1/2;
        J3F = 1/2;

      elseif (i == 2*NBEAMS),
        DMF = 1/2;
        CMF = -1/4;
        J1F = 1/2;
        J2F = 1/2;
        J3F = 1/2;
      else
        DMF = 1;
        CMF = 0;
        J1F = 1;
        J2F = 1;
        J3F = 1;
      end
      fprintf(fd, 'body: BAR_%d + %d, BAR_%d + %d,\n', j, i, j, i);
      fprintf(fd, '\t%f*m_%d*L_%d/(2*N_BEAMS),\n', DMF, j, j);
      fprintf(fd, '\treference, node, %f*L_%d/(2*N_BEAMS), 0., 0.,\n', CMF, j);
      fprintf(fd, '\tdiag,\n');
      fprintf(fd, '\t\t%f*J1_%d*L_%d/(2*N_BEAMS),\n', J1F, j, j);
      fprintf(fd, '\t\t%f*J2_%d*L_%d/(2*N_BEAMS) + (%f*m_%d/12)*(%f*L_%d/(2*N_BEAMS))^3,\n', J2F, j, j, DMF, j, DMF, j);
      fprintf(fd, '\t\t%f*J3_%d*L_%d/(2*N_BEAMS) + (%f*m_%d/12)*(%f*L_%d/(2*N_BEAMS))^3;\n', J3F, j, j, DMF, j, DMF, j);
    end
    fprintf(fd, '\n');

    fprintf(fd, 'constitutive law: BAR_%d, 6, linear viscoelastic generic, diag,\n', j);
    fprintf(fd, '\tEA_%d, GAY_%d, GAZ_%d, GJ_%d, EJY_%d, EJZ_%d,\n', j, j, j, j, j, j);
    fprintf(fd, '\tproportional, DAMPING_FACTOR;\n');
    fprintf(fd, '\n');
    for i = 1:NBEAMS,
      fprintf(fd, 'beam3: BAR_%d + %d,\n', j, i);
      fprintf(fd, '\tBAR_%d + %d, position, reference, node, null,\n', j, 2*i - 2)
      fprintf(fd, '\tBAR_%d + %d, position, reference, node, null,\n', j, 2*i - 1)
      fprintf(fd, '\tBAR_%d + %d, position, reference, node, null,\n', j, 2*i - 0)
      fprintf(fd, '\treference, %d, eye,\n', j);
      fprintf(fd, '\treference, BAR_%d,\n', j);
      fprintf(fd, '\tsame,\n');
      fprintf(fd, '\tsame;\n');
    end
    fprintf(fd, '\n');
  end

  fprintf(fd, '\n');
  fprintf(fd, '# vim:ft=mbd\n');

  fclose(fd);

  pkg load mboct-mbdyn-pkg;

  ad = [false, true];
  static = [false, true];

  max_diff = 0;

  for l=1:numel(static)
    fd = -1;
    unwind_protect
      fd = fopen("fourbar_static.con", "wt");
      if (fd == -1)
        error("failed to open file");
      endif
      if (static(l))
        fputs(fd, "model: static;\n");
      else
        fputs(fd, "## model: dynamic;\n");
      endif
    unwind_protect_cleanup
      if (fd ~= -1)
        fclose(fd);
      endif
    end_unwind_protect
    for k=1:numel(ad)
      fd = -1;
      unwind_protect
        fd = fopen("fourbar_ad.con", "wt");
        if (fd == -1)
          error("failed to open file");
        endif
        if (ad(k))
          fputs(fd, "use automatic differentiation;\n");
        else
          fputs(fd, "## use automatic differentiation;\n");
        endif
      unwind_protect_cleanup
        if (fd ~= -1)
          fclose(fd);
        endif
      end_unwind_protect
      opts.verbose = false;
      opts.output_file = "stage1";
      opts.logfile = "stage1.stdout";
      mbdyn_solver_run("fourbar_stage1.mbd", opts);
      opts.output_file = "stage2";
      opts.logfile = "stage2.stdout";
      mbdyn_solver_run("fourbar_stage2.mbd", opts);

      [t1, traj1, def1, vel1, acc1, node_id1] = mbdyn_post_load_output_struct("stage1");
      [t2, traj2, def2, vel2, acc2, node_id2] = mbdyn_post_load_output_struct("stage2");

      curr_diff = 0;

      for j=1:numel(traj1)
        x2 = traj2{j};
        x1 = zeros(size(x2));

        for i=1:columns(x1)
          x1(:, i) = interp1(t1, traj1{j}(:, i), t2);
        endfor

        curr_diff = max(curr_diff, max(max(abs(x1 - x2))) / max(1,max(max(abs(x1)))));
      endfor

      max_diff = max(max_diff, curr_diff);
      fprintf(stderr, "[%d, %d]: max difference: %e\n", l, k, curr_diff);
    endfor
  endfor
  tol = 1e-10;
  assert(max_diff < tol);
catch
  gtest_error = lasterror();
  gtest_fail(gtest_error, __FILE__);
  rethrow(gtest_error);
end_try_catch

% MBDyn (C) is a multibody analysis code. 
% http://www.mbdyn.org
% 
% Copyright (C) 1996-2025
% 
% Pierangelo Masarati	<masarati@aero.polimi.it>
% Paolo Mantegazza	<mantegazza@aero.polimi.it>
% 
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
% 
% Changing this copyright notice is forbidden.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
% 

try
  clear all;
  close all;
  
  pkg_prefix = getenv("OCT_PKG_INSTALL_PREFIX");

  if (~isempty(pkg_prefix))
    pkg("local_list", fullfile(pkg_prefix, "octave_packages"));
  endif
  
  NBEAMS = 5;

  E = 70e9;
  nu = 0.3;
  G = E/(2*(1 + nu));
  L = 0.508;
  a = 3.175e-3;
  b = 12.7e-3;

  ## EA = E*a*b;
  ## GAY = G*a*b; ##  FIXME
  ## GAZ = G*a*b; ##  FIXME
  ## GJ = G*a^2*b^2; ##  FIXME
  ## EJY = E*a^3*b/12;
  ## EJZ = E*a*b^3/12;

  ##  From PrincetonBeamDescription.pdf
  ## EA = 2.84e6;
  ## EJY = 2.43;
  ## EJZ = 36.28;
  ## GJ = 3.10;
  ## GAY = 0.90e6;
  ## GAZ = 0.64e6;

  EA = 2.84191e+006;
  EJY = 3.62794e+001;
  EJZ = 2.42873e+000;
  GJ = 3.10338e+000;
  GAY = 6.40131e+005;
  GAZ = 9.03881e+005;

  fd = fopen('princeton.set', 'w');
  fprintf(fd, '# generated by princeton_gen.m; do not edit\n');
  fprintf(fd, '\n');

  fprintf(fd, 'set: const integer N_BEAM_NODES = %d;\n', 2*NBEAMS);
  fprintf(fd, 'set: const integer N_BEAMS = %d;\n', NBEAMS);

  fprintf(fd, '\n');

  fprintf(fd, 'set: ifndef real THETA = 0.;\n');
  fprintf(fd, 'set: const real P1 = 4.448;\n');
  fprintf(fd, 'set: const real P2 = 8.896;\n');
  fprintf(fd, 'set: const real P3 = 13.345;\n');
  fprintf(fd, 'set: ifndef real P = P1;\n');

  fprintf(fd, '\n');

  fprintf(fd, 'set: const real L = %+16.8e;\n', L);
  fprintf(fd, 'set: const real EA = %+16.8e;\n', EA);
  fprintf(fd, 'set: const real GAY = %+16.8e;\n', GAY);
  fprintf(fd, 'set: const real GAZ = %+16.8e;\n', GAZ);
  fprintf(fd, 'set: const real GJ = %+16.8e;\n', GJ);
  fprintf(fd, 'set: const real EJY = %+16.8e;\n', EJY);
  fprintf(fd, 'set: const real EJZ = %+16.8e;\n', EJZ);

  fclose(fd);


  fd = fopen('princeton.ref', 'w');
  fprintf(fd, '# generated by princeton_gen.m; do not edit\n');
  fprintf(fd, '\n');

  fprintf(fd, 'reference: 1,\n');
  fprintf(fd, '\treference, global, null,\n');
  fprintf(fd, '\treference, global,\n');
  fprintf(fd, '\t\t1, 1., 0., 0.,\n');
  fprintf(fd, '#\t\t2, 0., cos(THETA*deg2rad), sin(THETA*deg2rad),\n');
  fprintf(fd, '\t\t2, 0., 1., 0.,\n');
  fprintf(fd, '\treference, global, null,\n');
  fprintf(fd, '\treference, global, null;\n');


  fclose(fd);


  fd = fopen('princeton.nod', 'w');
  fprintf(fd, '# generated by princeton_gen.m; do not edit\n');
  fprintf(fd, '\n');

  DL = L/(2*NBEAMS);
  for i = 1:2*NBEAMS,
    fprintf(fd, 'structural: %d, static,\n', i);
    fprintf(fd, '\treference, 1, %+16.8e,%+16.8e,%+16.8e,\n', i*DL, 0., 0.);
    fprintf(fd, '\treference, 1, eye,\n');
    fprintf(fd, '\treference, 1, null,\n');
    fprintf(fd, '\treference, 1, null;\n');
  end

  fclose(fd);


  fd = fopen('princeton.elm', 'w');
  fprintf(fd, '# generated by princeton_gen.m; do not edit\n');
  fprintf(fd, '\n');

  fprintf(fd, 'constitutive law: 1, 6,\n');
  fprintf(fd, '\tlinear elastic generic, diag, EA, GAY, GAZ, GJ, EJY, EJZ;\n');
  fprintf(fd, '\n');

  for i = 1:NBEAMS,
    fprintf(fd, 'beam3: %d,\n', i);
    fprintf(fd, '\t%d, reference, node, null,\n', 2*i - 2)
    fprintf(fd, '\t%d, reference, node, null,\n', 2*i - 1)
    fprintf(fd, '\t%d, reference, node, null,\n', 2*i - 0)
    fprintf(fd, '\treference, 1, eye,\n');
    fprintf(fd, '\treference, 1,\n');
    fprintf(fd, '\tsame,\n');
    fprintf(fd, '\tsame;\n');
  end

  fclose(fd);

  pkg load mboct-mbdyn-pkg;

  ad = [false, true];
  
  max_diff = 0;

  for k=1:numel(ad)
    fd = -1;
    unwind_protect
      fd = fopen("princeton_ad.con", "wt");
      if (fd == -1)
        error("failed to open file");
      endif
      if (ad(k))
        fputs(fd, "use automatic differentiation;\n");
      else
        fputs(fd, "## use automatic differentiation;\n");
      endif
    unwind_protect_cleanup
      if (fd ~= -1)
        fclose(fd);
      endif
    end_unwind_protect
    
    opts.output_file = "stage1";
    opts.logfile = "stage1.stdout";
    mbdyn_solver_run("princeton_stage1.mbd", opts);
    opts.output_file = "stage2";
    opts.logfile = "stage2.stdout";
    mbdyn_solver_run("princeton_stage2.mbd", opts);

    [t1, traj1, def1, vel1, acc1, node_id1] = mbdyn_post_load_output_struct("stage1");
    [t2, traj2, def2, vel2, acc2, node_id2] = mbdyn_post_load_output_struct("stage2");

    for j=1:numel(traj1)
      x2 = traj2{j};
      x1 = zeros(size(x2));

      for i=1:columns(x1)
        x1(:, i) = interp1(t1, traj1{j}(:, i), t2);
      endfor

      curr_diff = max(max(abs(x1 - x2))) / max(1,max(max(abs(x1))));
      max_diff = max(max_diff, curr_diff);
      fprintf(stderr, "max difference node %d: %e\n", node_id1(j), curr_diff);
    endfor
  endfor
  tol = 1e-10;
  assert(max_diff < tol);
catch
  gtest_error = lasterror();
  gtest_fail(gtest_error, __FILE__);
  rethrow(gtest_error);
end_try_catch
